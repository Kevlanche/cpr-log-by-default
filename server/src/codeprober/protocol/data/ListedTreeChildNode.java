// Automatically generated by protocolgen.GenJava. DO NOT MODIFY
package codeprober.protocol.data;

import org.json.JSONObject;

@SuppressWarnings("unchecked")
public class ListedTreeChildNode implements codeprober.util.JsonUtil.ToJsonable {
  public static enum Type {
    children,
    placeholder,
  }

  public final Type type;
  public final Object value;
  private ListedTreeChildNode(Type type, Object value) {
    this.type = type;
    this.value = value;
  }
  public static ListedTreeChildNode fromChildren(java.util.List<ListedTreeNode> val) { return new ListedTreeChildNode(Type.children, val); }
  public static ListedTreeChildNode fromPlaceholder(int val) { return new ListedTreeChildNode(Type.placeholder, val); }

  public boolean isChildren() { return type == Type.children; }
  public java.util.List<ListedTreeNode> asChildren() { if (type != Type.children) { throw new IllegalStateException("This ListedTreeChildNode is not of type children, it is '" + type + "'"); } return (java.util.List<ListedTreeNode>)value; }
  public boolean isPlaceholder() { return type == Type.placeholder; }
  public int asPlaceholder() { if (type != Type.placeholder) { throw new IllegalStateException("This ListedTreeChildNode is not of type placeholder, it is '" + type + "'"); } return (int)value; }

  public static ListedTreeChildNode fromJSON(JSONObject obj) {
    final Type type;
    try { type = Type.valueOf(obj.getString("type")); }
    catch (IllegalArgumentException e) { throw new org.json.JSONException(e); }
    switch (type) {
    case children:
      try {
        final java.util.List<ListedTreeNode> val = codeprober.util.JsonUtil.<ListedTreeNode>mapArr(obj.getJSONArray("value"), (arr, idx) -> ListedTreeNode.fromJSON(arr.getJSONObject(idx)));
        return fromChildren(val);
      } catch (org.json.JSONException e) {
        throw new org.json.JSONException("Not a valid ListedTreeChildNode", e);
      }
    case placeholder:
    default:
      try {
        final int val = obj.getInt("value");
        return fromPlaceholder(val);
      } catch (org.json.JSONException e) {
        throw new org.json.JSONException("Not a valid ListedTreeChildNode", e);
      }
    }
  }

  public JSONObject toJSON() {
    final JSONObject ret = new JSONObject().put("type", type.name());
    switch (type) {
    case children:
      ret.put("value", new org.json.JSONArray(((java.util.List<ListedTreeNode>)value).stream().<Object>map(x->x.toJSON()).collect(java.util.stream.Collectors.toList())));
      break;
    case placeholder:
    default:
      ret.put("value", ((int)value));
      break;
    }
    return ret;
  }
}
