// Automatically generated by protocolgen.GenJava. DO NOT MODIFY
package codeprober.protocol.data;

import org.json.JSONObject;

public class NodeLocatorStep implements codeprober.util.JsonUtil.ToJsonable {
  public static enum Type {
    child,
    nta,
    tal,
  }

  public final Type type;
  public final Object value;
  private NodeLocatorStep(Type type, Object value) {
    this.type = type;
    this.value = value;
  }
  public static NodeLocatorStep fromChild(int val) { return new NodeLocatorStep(Type.child, val); }
  public static NodeLocatorStep fromNta(FNStep val) { return new NodeLocatorStep(Type.nta, val); }
  public static NodeLocatorStep fromTal(TALStep val) { return new NodeLocatorStep(Type.tal, val); }

  public boolean isChild() { return type == Type.child; }
  public int asChild() { if (type != Type.child) { throw new IllegalStateException("This NodeLocatorStep is not of type child, it is '" + type + "'"); } return (int)value; }
  public boolean isNta() { return type == Type.nta; }
  public FNStep asNta() { if (type != Type.nta) { throw new IllegalStateException("This NodeLocatorStep is not of type nta, it is '" + type + "'"); } return (FNStep)value; }
  public boolean isTal() { return type == Type.tal; }
  public TALStep asTal() { if (type != Type.tal) { throw new IllegalStateException("This NodeLocatorStep is not of type tal, it is '" + type + "'"); } return (TALStep)value; }

  public static NodeLocatorStep fromJSON(JSONObject obj) {
    final Type type;
    try { type = Type.valueOf(obj.getString("type")); }
    catch (IllegalArgumentException e) { throw new org.json.JSONException(e); }
    switch (type) {
    case child:
      try {
        final int val = obj.getInt("value");
        return fromChild(val);
      } catch (org.json.JSONException e) {
        throw new org.json.JSONException("Not a valid NodeLocatorStep", e);
      }
    case nta:
      try {
        final FNStep val = FNStep.fromJSON(obj.getJSONObject("value"));
        return fromNta(val);
      } catch (org.json.JSONException e) {
        throw new org.json.JSONException("Not a valid NodeLocatorStep", e);
      }
    case tal:
    default:
      try {
        final TALStep val = TALStep.fromJSON(obj.getJSONObject("value"));
        return fromTal(val);
      } catch (org.json.JSONException e) {
        throw new org.json.JSONException("Not a valid NodeLocatorStep", e);
      }
    }
  }

  public JSONObject toJSON() {
    final JSONObject ret = new JSONObject().put("type", type.name());
    switch (type) {
    case child:
      ret.put("value", ((int)value));
      break;
    case nta:
      ret.put("value", ((FNStep)value).toJSON());
      break;
    case tal:
    default:
      ret.put("value", ((TALStep)value).toJSON());
      break;
    }
    return ret;
  }
}
